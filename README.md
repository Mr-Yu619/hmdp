# 代码使用说明(本项目来自b站[黑马程序员](https://space.bilibili.com/37974444)[redis教程](https://www.bilibili.com/video/BV1cr4y1671t)，仅供参考)
- 前端资源在src/main/resources/nginx-1.18.0下

视频地址:
- [黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+redis实战](https://www.bilibili.com/video/BV1cr4y1671t)
- [https://www.bilibili.com/video/BV1cr4y1671t](https://www.bilibili.com/video/BV1cr4y1671t)
  - P24起 实战篇

## 1.下载
克隆完整项目
```git
git clone https://github.com/Mr-Yu619/hmdp.git
```
切换分支
```git
git checkout init
```
## 2.项目主要实现功能
### 2.1 优惠券模块
秒杀的逻辑应该是这样的
加了一个令牌桶算法，进行一个限流
先访问缓存，这时候有三种情况
0.缓存中没有这个键，此时redis中还没有这个数据（其实这一步可以在添加秒杀优惠券的时候就放进去，然后设置逻辑过期，但问题是没设计这个接口md）
1.缓存中有这个键，但是用户没有购买权限
2.缓存中有这个键，且有购买权限，但是库存不够了
3.缓存中有这个键，且有购买权限，买了，更新缓存了
访问完缓存，建一个订单项，交给消息队列，让消息队列自己去处理

那么redis在这里的作用是什么呢？
快速判断是否满足资格，对于不成功的操作会加快处理时间，成功的操作就是与操作数据库一样的处理时间

消息队列：
生产者生产消息（消息这里是订单entity变成的JSON对象）到交换机上，交换机根据路由键来选择要转发的队列
会有一个Bean对象，里面有监听特定队列的方法，然后内部处理逻辑是这样的
它需要操作的是数据库，首先就是一人一单的判断，redis判断完不行，因为可能此时还么（还用判断么？）
然后尝试扣减库存（seckillVoucher表中的数据），这是用了乐观锁，不能出现负数库存，如果成功操作了
那么把订单信息保存起来
### 2.2 商户模块
商户查询中使用了逻辑过期和缓存空值来缓解缓存击穿和缓存穿透问题
初始代码中没有考虑逻辑过期查询中redis中数据初始化的问题，它的思路是如果查不到直接返回（实际上可能还没有建立好缓存）
主要逻辑如下
- 查询缓存，如果有内容
  - 缓存如果没过期，直接返回商户信息
  - 如果过期了，需要重建缓存，此时需要获取锁，然后获取到锁的线程提交更新缓存这个任务到线程池，然后和其他线程一样直接返回旧数据
- 没查到内容，isblank判true
  - 如果是""值，说明这是为了防止缓存穿透写进的数据，那么直接返回失败
  - 如果是null值，说明redis中确实没有，此时需要访问数据库
    - 查询数据库，如果没查到，写""到缓存中，返回
    - 查到了，写商户信息到缓存中，包含逻辑过期时间的数据格式，返回
### 2.3 博客模块
主页会显示热门博客，是直接在数据库中查找的
实现了点赞博客和显示点赞用户功能
用redis的Zset记录一个博客的点赞用户id和点赞时间，根据点赞时间进行排序
如果Zset中有这个元素，那么删除redis中的数据同时更新数据库
如果Zset没有这个元素，那么添加redis中的数据同时更新数据库
### 2.4 用户模块
主要是发送验证码和登陆两个模块
发送验证码的逻辑
- 检查手机号格式
- 看是否在一级限制内，如果是那么拒绝发送（五分钟内发了五次）
- 看是否在二级限制内，如果是那么拒绝发送（五分钟内发了大于次）
- 都不是则检查发了几次，如果当前次数已经到了临界条件，设置好级别，根据Zset查询，Zset的value和score都是时间戳
- 如果不是发送验证码，并且添加这次记录到Zset中，把验证码写到redis中
登陆的逻辑
- 检查手机号，不正确则返回
- 从redis中拿验证码，和传过来的code做比较
- 如果不正确返回
- 如果正确了，查询数据库，看有没有该用户
  - 如果没有，在数据库中新创建一个用户
  - 然后设置好各种基本信息，把user对象转化为UserDTO对象存到redis中
校验登陆逻辑
- 有两个拦截器，一个负责从redis中拿数据放到ThreadLocal里，并且更新redis中的过期时间，都是有则做没有就不管放行的策略
- 第二个拦截器，是从ThreadLocal中拿出，如果获取到了就放行，没有就拦截
